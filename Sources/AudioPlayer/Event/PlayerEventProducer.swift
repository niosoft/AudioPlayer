//
//  PlayerEventProducer.swift
//  AudioPlayer
//
//  Created by Dionisis Karatzas on 20/9/22.
//  Copyright Â© 2022 Niosoft. All rights reserved.
//

import AVFoundation
import AVFoundationCombine
import Combine

// MARK: - PlayerEventProducer

/// A `PlayerEventProducer` listens to notifications and observes events generated by an AVPlayer.
class PlayerEventProducer: EventProducer {
    /// A `PlayerEvent` is an event a player generates over time.
    ///
    /// - startedBuffering: The player started buffering the audio file.
    /// - readyToPlay: The player is ready to play. It buffered enough data.
    /// - loadedMoreRange: The player loaded more range of time.
    /// - loadedMetadata: The player loaded metadata.
    /// - loadedDuration: The player has found audio item duration.
    /// - progressed: The player progressed in its playing.
    /// - endedPlaying: The player ended playing the current item because it went through the
    ///     file or because of an error.
    /// - interruptionBegan: The player got interrupted (phone call, Siri, ...).
    /// - interruptionEnded: The interruption ended.
    /// - routeChanged: The player's route changed.
    /// - sessionMessedUp: The audio session is messed up.
    enum PlayerEvent: Event {
        case startedBuffering
        case readyToPlay
        case loadedMoreRange(earliest: CMTime, latest: CMTime)
        case loadedMetadata(metadata: [AVMetadataItem])
        case loadedDuration(duration: CMTime)
        case progressed(time: CMTime)
        case endedPlaying(error: Error?)
        case interruptionBegan
        case interruptionEnded(shouldResume: Bool)
        case routeChanged
        case sessionMessedUp
    }

    /// The player to produce events with.
    ///
    /// Note that setting it has the same result as calling `stopProducingEvents`.
    var player: AVPlayer? {
        willSet {
            stopProducingEvents()
        }
    }

    /// The listener that will be alerted a new event occured.
    weak var eventListener: EventListener?

    /// A boolean value indicating whether we're currently listening to events on the player.
    private var listening = false

    /// The registered subscriptions
    private var cancellableBag = Set<AnyCancellable>()

    /// Stops producing events on deinitialization.
    deinit {
        stopProducingEvents()
    }

    /// Starts listening to the player events.
    func startProducingEvents() {
        guard let player = player, !listening else {
            return
        }

        // Observing notifications sent through `NSNotificationCenter`
        let center = NotificationCenter.default
#if os(iOS) || os(tvOS)
        center
            .publisher(for: AVAudioSession.interruptionNotification)
            .sink {[weak self] notification in
                self?.audioSessionGotInterrupted(notification: notification)
            }
            .store(in: &cancellableBag)

        center
            .publisher(for: AVAudioSession.routeChangeNotification)
            .sink { [weak self] notification in
                self?.audioSessionRouteChanged(notification: notification)
            }
            .store(in: &cancellableBag)

        center
            .publisher(for: AVAudioSession.mediaServicesWereLostNotification)
            .sink { [weak self] notification in
                self?.audioSessionMessedUp(notification: notification)
            }
            .store(in: &cancellableBag)

        center
            .publisher(for: AVAudioSession.mediaServicesWereResetNotification)
            .sink { [weak self] notification in
                self?.audioSessionMessedUp(notification: notification)
            }
            .store(in: &cancellableBag)
#endif
        center
            .publisher(for: .AVPlayerItemDidPlayToEndTime)
            .sink { [weak self] notification in
                self?.playerItemDidEnd(notification: notification)
            }
            .store(in: &cancellableBag)

        player
            .currentItemPublisher()
            .sink {[weak self] item in
                guard let item else { return }
                self?.registerItemObservers(item)
            }
            .store(in: &cancellableBag)


        // Observing timing event
        player
            .playheadProgressPublisher(interval: 1)
            .sink {[weak self] interval in
                guard let self else { return }

                let time = CMTime(seconds: interval, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
                self.eventListener?.onEvent(PlayerEvent.progressed(time: time), generetedBy: self)
            }
            .store(in: &cancellableBag)

        listening = true
    }

    private func registerItemObservers(_ item: AVPlayerItem) {
        item
            .isPlaybackBufferEmptyPublisher()
            .dropFirst()
            .sink {[weak self] isPlaybackBufferEmpty in
                guard let self, isPlaybackBufferEmpty else { return }
                self.eventListener?.onEvent(PlayerEvent.startedBuffering, generetedBy: self)
            }
            .store(in: &self.cancellableBag)

        item
            .isPlaybackLikelyToKeepUpPublisher()
            .dropFirst()
            .sink {[weak self] isPlaybackLikelyToKeepUp in
                guard let self, isPlaybackLikelyToKeepUp else { return }
                self.eventListener?.onEvent(PlayerEvent.readyToPlay, generetedBy: self)
            }
            .store(in: &self.cancellableBag)

        item
            .durationPublisher()
            .dropFirst()
            .sink {[weak self] duration in
                guard let self else { return }
                self.eventListener?.onEvent(PlayerEvent.loadedDuration(duration: duration), generetedBy: self)

                self.eventListener?.onEvent(PlayerEvent.loadedMetadata(metadata: item.asset.commonMetadata), generetedBy: self)
            }
            .store(in: &self.cancellableBag)

        item
            .statusPublisher()
            .dropFirst()
            .sink {[weak self] status in
                guard let self else { return }

                if status == .failed {
                    self.eventListener?.onEvent(PlayerEvent.endedPlaying(error: item.error), generetedBy: self)
                } else if status == .readyToPlay {
                    self.eventListener?.onEvent(PlayerEvent.readyToPlay, generetedBy: self)
                }
            }
            .store(in: &self.cancellableBag)

        item
            .loadedTimeRangesPublisher()
            .dropFirst()
            .sink {[weak self] loadedTimeRanges in
                guard let self else { return }

                if let range = loadedTimeRanges.last?.timeRangeValue {
                    self.eventListener?.onEvent(PlayerEvent.loadedMoreRange(earliest: range.start, latest: range.end), generetedBy: self)
                }
            }
            .store(in: &self.cancellableBag)

        item
            .timedMetadataPublisher()
            .dropFirst()
            .sink {[weak self] timedMetadata in
                guard let self else { return }

                if let metadata = timedMetadata {
                    self.eventListener?.onEvent(PlayerEvent.loadedMetadata(metadata: metadata), generetedBy: self)
                }
            }
            .store(in: &self.cancellableBag)
    }

    /// Stops listening to the player events.
    func stopProducingEvents() {
        cancellableBag.removeAll()

        listening = false
    }

#if os(iOS) || os(tvOS)
    /// Audio session got interrupted by the system (call, Siri, ...). If interruption begins, we should ensure the
    /// audio pauses and if it ends, we should restart playing if state was `.playing` before.
    ///
    /// - Parameter note: The notification information.
    fileprivate func audioSessionGotInterrupted(notification: Notification) {
        if let userInfo = notification.userInfo, let type = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
           let interruption = AVAudioSession.InterruptionType(rawValue: type) {

            if interruption == .began {
                eventListener?.onEvent(PlayerEvent.interruptionBegan, generetedBy: self)
            } else {
                if let type = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt {
                    let options = AVAudioSession.InterruptionOptions(rawValue: type)
                    eventListener?.onEvent(
                        PlayerEvent.interruptionEnded(shouldResume: options.contains(.shouldResume)),
                        generetedBy: self
                    )
                }
            }
        }
    }
#endif

    /// Audio session route changed (ex: earbuds plugged in/out). This can change the player state, so we just adapt it.
    ///
    /// - Parameter note: The notification information.
    fileprivate func audioSessionRouteChanged(notification: Notification) {
        eventListener?.onEvent(PlayerEvent.routeChanged, generetedBy: self)
    }

    /// Audio session got messed up (media services lost or reset). We gotta reactive the audio session and reset
    /// player.
    ///
    /// - Parameter note: The notification information.
    fileprivate func audioSessionMessedUp(notification: Notification) {
        eventListener?.onEvent(PlayerEvent.sessionMessedUp, generetedBy: self)
    }

    /// Playing item did end. We can play next or stop the player if queue is empty.
    ///
    /// - Parameter note: The notification information.
    fileprivate func playerItemDidEnd(notification: Notification) {
        eventListener?.onEvent(PlayerEvent.endedPlaying(error: nil), generetedBy: self)
    }
}
